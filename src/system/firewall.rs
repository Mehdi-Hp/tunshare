//! Packet filter (pf) firewall management.

use crate::error::{Result, TunshareError};
use std::fs;
use std::path::Path;
use tokio::process::Command;

const PF_CONF_PATH: &str = "/tmp/tunshare_pf.conf";
const DEFAULT_PF_CONF: &str = "/etc/pf.conf";

/// Manages pf firewall rules for VPN sharing.
pub struct Firewall {
    /// Whether we have active rules loaded.
    rules_loaded: bool,
    /// The config file path we're using.
    config_path: String,
}

impl Firewall {
    pub fn new() -> Self {
        Self {
            rules_loaded: false,
            config_path: PF_CONF_PATH.to_string(),
        }
    }

    /// Generate pf rules for NAT from LAN to VPN.
    /// Rules must be in order: options, normalization, translation, filtering
    ///
    /// We intentionally don't use "block all" because that would block the Mac's
    /// own connection to the VPN server, disconnecting the VPN when rules load.
    ///
    /// Note: NAT translation happens BEFORE filter rules, so outgoing filter rules
    /// must match the post-NAT source address (the VPN interface), not the original
    /// LAN address.
    pub fn generate_rules(vpn_if: &str, lan_if: &str, mss: u16) -> String {
        format!(
            r#"# VPN Sharing pf rules - generated by tunshare
# VPN interface: {vpn_if}
# LAN interface: {lan_if}

# 1. Options
set skip on lo0

ext_if = "{vpn_if}"
int_if = "{lan_if}"

# 2. Normalization (must come before translation)
scrub in all no-df
scrub out on $ext_if inet proto tcp from $int_if:network to any max-mss {mss}

# 3. Translation - NAT LAN traffic through VPN
nat on $ext_if inet from $int_if:network to any -> ($ext_if) static-port
rdr-anchor "natpmp"

# 4. Filtering
# Allow all traffic on LAN interface (including DHCP from 0.0.0.0)
pass quick on $int_if all keep state
# Allow NAT'd traffic out (post-NAT, source is VPN interface address)
pass out quick on $ext_if inet from ($ext_if) to any keep state
anchor "natpmp"
"#
        )
    }

    /// Validate a pf configuration file.
    pub async fn validate_rules(config_path: &str) -> Result<()> {
        let output = Command::new("pfctl")
            .args(["-n", "-f", config_path])
            .output()
            .await
            .map_err(|e| TunshareError::CommandFailed {
                command: "pfctl -n -f".into(),
                message: e.to_string(),
            })?;

        let stderr = String::from_utf8_lossy(&output.stderr);

        // pfctl on macOS prints warnings to stderr even on success
        // Only treat as error if exit status is non-zero AND stderr contains actual errors
        if !output.status.success() {
            // Check for actual error indicators (not just warnings)
            let has_error = stderr.contains("syntax error")
                || stderr.contains("unknown")
                || stderr.contains("invalid")
                || stderr.contains("no valid")
                || (stderr.contains("error") && !stderr.contains("0 errors"));

            if has_error {
                return Err(TunshareError::FirewallError(format!(
                    "Rule validation failed: {}",
                    stderr.trim()
                )));
            }
        }

        Ok(())
    }

    /// Load pf rules from the generated config.
    pub async fn load_rules(&mut self, vpn_if: &str, lan_if: &str) -> Result<()> {
        // Generate rules with default MSS (1400 is safe for most VPNs)
        let rules = Self::generate_rules(vpn_if, lan_if, 1400);

        // Write to temp file
        fs::write(&self.config_path, &rules).map_err(TunshareError::Io)?;

        // Validate first
        Self::validate_rules(&self.config_path).await?;

        // Enable pf if not already enabled
        let _ = Command::new("pfctl").args(["-e"]).output().await;

        // Load the rules
        let output = Command::new("pfctl")
            .args(["-f", &self.config_path])
            .output()
            .await
            .map_err(|e| TunshareError::CommandFailed {
                command: "pfctl -f".into(),
                message: e.to_string(),
            })?;

        let stderr = String::from_utf8_lossy(&output.stderr);

        // pfctl on macOS prints warnings to stderr even on success
        // "Use of -f option, could disable the actions of the service" is just a warning
        // Only treat as error if there's an actual failure indicator
        if !output.status.success() {
            let is_just_warning = stderr.contains("Use of -f option")
                || stderr.contains("rules loaded")
                || stderr.contains("pf enabled");

            let stderr_lower = stderr.to_lowercase();
            let has_real_error = stderr_lower.contains("syntax error")
                || stderr_lower.contains("rules not loaded")
                || stderr.contains("unknown")
                || stderr.contains("invalid")
                || stderr.contains("no valid");

            if has_real_error && !is_just_warning {
                return Err(TunshareError::FirewallError(format!(
                    "Failed to load rules: {}",
                    stderr.trim()
                )));
            }
        }

        self.rules_loaded = true;
        Ok(())
    }

    /// Stop sharing and restore default pf rules (async wrapper).
    /// Delegates to `cleanup_sync` via `spawn_blocking`.
    pub async fn cleanup(&mut self) -> Result<()> {
        let config_path = self.config_path.clone();
        tokio::task::spawn_blocking(move || cleanup_sync_impl(&config_path))
            .await
            .map_err(|e| TunshareError::CommandFailed {
                command: "cleanup (spawn_blocking)".into(),
                message: e.to_string(),
            })??;

        self.rules_loaded = false;
        Ok(())
    }

    /// Get current pf rules (for debugging).
    /// Returns both NAT rules (-sn) and filter rules (-sr).
    pub async fn get_current_rules() -> Result<String> {
        // Get NAT rules
        let nat_output = Command::new("pfctl")
            .args(["-sn"])
            .output()
            .await
            .map_err(|e| TunshareError::CommandFailed {
                command: "pfctl -sn".into(),
                message: e.to_string(),
            })?;

        // Get filter rules
        let filter_output = Command::new("pfctl")
            .args(["-sr"])
            .output()
            .await
            .map_err(|e| TunshareError::CommandFailed {
                command: "pfctl -sr".into(),
                message: e.to_string(),
            })?;

        let nat_rules = String::from_utf8_lossy(&nat_output.stdout);
        let filter_rules = String::from_utf8_lossy(&filter_output.stdout);

        let mut result = String::new();
        if !nat_rules.trim().is_empty() {
            result.push_str(&nat_rules);
        }
        if !filter_rules.trim().is_empty() {
            if !result.is_empty() {
                result.push('\n');
            }
            result.push_str(&filter_rules);
        }

        Ok(result)
    }

    /// Get current pf states (for debugging).
    pub async fn get_current_states() -> Result<String> {
        let output = Command::new("pfctl")
            .args(["-ss"])
            .output()
            .await
            .map_err(|e| TunshareError::CommandFailed {
                command: "pfctl -ss".into(),
                message: e.to_string(),
            })?;

        Ok(String::from_utf8_lossy(&output.stdout).to_string())
    }

    /// Check if pf is enabled.
    pub async fn is_enabled() -> Result<bool> {
        let output = Command::new("pfctl")
            .args(["-si"])
            .output()
            .await
            .map_err(|e| TunshareError::CommandFailed {
                command: "pfctl -si".into(),
                message: e.to_string(),
            })?;

        let stdout = String::from_utf8_lossy(&output.stdout);
        Ok(stdout.contains("Status: Enabled"))
    }

    #[allow(dead_code)]
    pub fn is_loaded(&self) -> bool {
        self.rules_loaded
    }

    /// Synchronous cleanup for use in Drop and async wrapper.
    pub fn cleanup_sync(&mut self) {
        let _ = cleanup_sync_impl(&self.config_path);
        self.rules_loaded = false;
    }
}

impl Default for Firewall {
    fn default() -> Self {
        Self::new()
    }
}

impl Drop for Firewall {
    fn drop(&mut self) {
        // Attempt cleanup on drop, but don't panic on failure
        if self.rules_loaded {
            self.cleanup_sync();
        }
    }
}

/// Standalone sync cleanup logic. Single source of truth for both
/// `cleanup_sync()` and `cleanup()` (via `spawn_blocking`).
fn cleanup_sync_impl(config_path: &str) -> Result<()> {
    use std::process::Command as SyncCommand;

    let mut errors = Vec::new();

    // 1. Restore default pf rules (don't flush states - that kills VPN)
    if Path::new(DEFAULT_PF_CONF).exists() {
        let output = SyncCommand::new("pfctl")
            .args(["-f", DEFAULT_PF_CONF])
            .output();
        if let Ok(output) = output {
            if !output.status.success() {
                let stderr = String::from_utf8_lossy(&output.stderr);
                if !stderr.contains("rules loaded") && stderr.contains("error") {
                    errors.push(format!("Failed to restore default rules: {}", stderr));
                }
            }
        }
    } else {
        let _ = SyncCommand::new("pfctl").args(["-d"]).output();
    }

    // 2. Remove our config file
    if Path::new(config_path).exists() {
        if let Err(e) = fs::remove_file(config_path) {
            errors.push(format!("Failed to remove config file: {}", e));
        }
    }

    if errors.is_empty() {
        Ok(())
    } else {
        Err(TunshareError::FirewallError(errors.join("; ")))
    }
}
