//! DHCP server management using dnsmasq for automatic router configuration.

use crate::error::{Result, VpnShareError};
use std::fs;
use std::path::Path;
use std::process::Command as SyncCommand;
use tokio::process::Command;

const DNSMASQ_CONF_PATH: &str = "/tmp/vpn-share-dnsmasq.conf";
const DNSMASQ_PID_PATH: &str = "/tmp/vpn-share-dnsmasq.pid";
const DNSMASQ_LEASE_PATH: &str = "/tmp/vpn-share-dnsmasq.leases";

/// DHCP server manager using dnsmasq.
pub struct DhcpServer {
    /// Whether the DHCP server is running.
    running: bool,
    /// The LAN interface to serve DHCP on.
    interface: String,
    /// The gateway IP (Mac mini's LAN IP).
    gateway_ip: String,
    /// DNS servers to advertise to clients.
    dns_servers: Vec<String>,
}

impl DhcpServer {
    /// Create a new DHCP server instance.
    pub fn new(interface: &str, gateway_ip: &str, dns_servers: Vec<String>) -> Self {
        Self {
            running: false,
            interface: interface.to_string(),
            gateway_ip: gateway_ip.to_string(),
            dns_servers,
        }
    }

    /// Check if dnsmasq is installed and return its path.
    pub fn find_dnsmasq() -> Option<String> {
        // Check common Homebrew locations first (sudo might not have them in PATH)
        let common_paths = [
            "/opt/homebrew/sbin/dnsmasq",
            "/usr/local/sbin/dnsmasq",
            "/opt/homebrew/bin/dnsmasq",
            "/usr/local/bin/dnsmasq",
        ];

        for path in common_paths {
            if Path::new(path).exists() {
                return Some(path.to_string());
            }
        }

        // Fall back to which command
        SyncCommand::new("which")
            .arg("dnsmasq")
            .output()
            .ok()
            .filter(|o| o.status.success())
            .and_then(|o| String::from_utf8(o.stdout).ok())
            .map(|s| s.trim().to_string())
    }

    /// Check if dnsmasq is installed.
    pub fn is_dnsmasq_installed() -> bool {
        Self::find_dnsmasq().is_some()
    }

    /// Calculate DHCP range from gateway IP.
    /// Given gateway 192.168.2.1, returns ("192.168.2.100", "192.168.2.150").
    pub fn calculate_dhcp_range(gateway_ip: &str) -> Option<(String, String)> {
        let parts: Vec<&str> = gateway_ip.split('.').collect();
        if parts.len() != 4 {
            return None;
        }

        // Use .100 to .150 range in the same subnet
        let prefix = format!("{}.{}.{}", parts[0], parts[1], parts[2]);
        Some((format!("{}.100", prefix), format!("{}.150", prefix)))
    }

    /// Generate dnsmasq configuration.
    fn generate_config(&self) -> String {
        let (range_start, range_end) =
            Self::calculate_dhcp_range(&self.gateway_ip).unwrap_or_else(|| {
                // Fallback range
                ("192.168.2.100".to_string(), "192.168.2.150".to_string())
            });

        let dns_option = if self.dns_servers.is_empty() {
            // Use gateway as DNS if no VPN DNS available
            format!("dhcp-option=6,{}", self.gateway_ip)
        } else {
            format!("dhcp-option=6,{}", self.dns_servers.join(","))
        };

        format!(
            r#"# VPN Share DHCP configuration - generated by vpn-share
# Interface: {interface}
# Gateway: {gateway}

# Only listen on the specified interface
interface={interface}
bind-interfaces

# Don't use /etc/resolv.conf
no-resolv

# Don't provide DNS service (just DHCP)
port=0

# DHCP range and lease time
dhcp-range={range_start},{range_end},12h

# Gateway (option 3) - Mac mini's LAN IP
dhcp-option=3,{gateway}

# DNS servers (option 6)
{dns_option}

# Lease file
dhcp-leasefile={lease_file}

# PID file
pid-file={pid_file}

# Only DHCP, no DNS
dhcp-authoritative
"#,
            interface = self.interface,
            gateway = self.gateway_ip,
            range_start = range_start,
            range_end = range_end,
            dns_option = dns_option,
            lease_file = DNSMASQ_LEASE_PATH,
            pid_file = DNSMASQ_PID_PATH,
        )
    }

    /// Start the DHCP server.
    pub async fn start(&mut self) -> Result<()> {
        if self.running {
            return Ok(());
        }

        let dnsmasq_path = Self::find_dnsmasq().ok_or_else(|| VpnShareError::CommandFailed {
            command: "dnsmasq".into(),
            message: "dnsmasq is not installed. Install with: brew install dnsmasq".into(),
        })?;

        // Stop any existing instance first
        Self::stop().await.ok();

        // Generate and write configuration
        let config = self.generate_config();
        fs::write(DNSMASQ_CONF_PATH, &config).map_err(VpnShareError::Io)?;

        // Start dnsmasq (it will daemonize itself)
        let conf_arg = format!("--conf-file={}", DNSMASQ_CONF_PATH);
        let output = Command::new(&dnsmasq_path)
            .arg(&conf_arg)
            .output()
            .await
            .map_err(|e| VpnShareError::CommandFailed {
                command: "dnsmasq".into(),
                message: e.to_string(),
            })?;

        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            return Err(VpnShareError::CommandFailed {
                command: "dnsmasq".into(),
                message: format!("Failed to start DHCP server: {}", stderr),
            });
        }

        self.running = true;
        Ok(())
    }

    /// Stop any running DHCP server instance.
    ///
    /// This is an associated function (no `self`) because it operates on
    /// well-known PID files and config paths, not instance state.
    pub async fn stop() -> Result<()> {
        // Try to read PID and kill the process
        if Path::new(DNSMASQ_PID_PATH).exists() {
            if let Ok(pid_str) = fs::read_to_string(DNSMASQ_PID_PATH) {
                if let Ok(pid) = pid_str.trim().parse::<i32>() {
                    // Send SIGTERM to dnsmasq
                    let _ = Command::new("kill").arg(pid.to_string()).output().await;
                }
            }
        }

        // Also try pkill as a fallback (only our instance)
        let _ = Command::new("pkill")
            .args(["-f", &format!("dnsmasq.*{}", DNSMASQ_CONF_PATH)])
            .output()
            .await;

        // Clean up files
        for path in [DNSMASQ_CONF_PATH, DNSMASQ_PID_PATH, DNSMASQ_LEASE_PATH] {
            if Path::new(path).exists() {
                let _ = fs::remove_file(path);
            }
        }

        Ok(())
    }

    /// Detach the server so `Drop` won't stop the daemon.
    ///
    /// Use this instead of `std::mem::forget` to keep the daemon running
    /// after the `DhcpServer` value is dropped.
    pub fn detach(&mut self) {
        self.running = false;
    }

    /// Synchronous stop for use in Drop.
    pub fn stop_sync() {
        // Try to read PID and kill the process
        if Path::new(DNSMASQ_PID_PATH).exists() {
            if let Ok(pid_str) = fs::read_to_string(DNSMASQ_PID_PATH) {
                if let Ok(pid) = pid_str.trim().parse::<i32>() {
                    let _ = SyncCommand::new("kill").arg(pid.to_string()).output();
                }
            }
        }

        // Also try pkill as a fallback
        let _ = SyncCommand::new("pkill")
            .args(["-f", &format!("dnsmasq.*{}", DNSMASQ_CONF_PATH)])
            .output();

        // Clean up files
        for path in [DNSMASQ_CONF_PATH, DNSMASQ_PID_PATH, DNSMASQ_LEASE_PATH] {
            if Path::new(path).exists() {
                let _ = fs::remove_file(path);
            }
        }
    }
}

impl Drop for DhcpServer {
    fn drop(&mut self) {
        if self.running {
            Self::stop_sync();
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_calculate_dhcp_range() {
        let range = DhcpServer::calculate_dhcp_range("192.168.2.1");
        assert_eq!(
            range,
            Some(("192.168.2.100".to_string(), "192.168.2.150".to_string()))
        );

        let range = DhcpServer::calculate_dhcp_range("10.0.0.1");
        assert_eq!(
            range,
            Some(("10.0.0.100".to_string(), "10.0.0.150".to_string()))
        );

        let range = DhcpServer::calculate_dhcp_range("invalid");
        assert_eq!(range, None);
    }

    #[test]
    fn test_generate_config() {
        let server = DhcpServer::new("en0", "192.168.2.1", vec!["10.8.0.1".to_string()]);
        let config = server.generate_config();

        assert!(config.contains("interface=en0"));
        assert!(config.contains("dhcp-range=192.168.2.100,192.168.2.150"));
        assert!(config.contains("dhcp-option=3,192.168.2.1"));
        assert!(config.contains("dhcp-option=6,10.8.0.1"));
    }
}
