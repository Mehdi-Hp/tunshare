//! DHCP server management using dnsmasq for automatic router configuration.

use crate::error::{Result, TunshareError};
use std::fs;
use std::net::Ipv4Addr;
use std::path::Path;
use std::process::Command as SyncCommand;
use tokio::process::Command;

const DNSMASQ_CONF_PATH: &str = "/tmp/tunshare-dnsmasq.conf";
const DNSMASQ_PID_PATH: &str = "/tmp/tunshare-dnsmasq.pid";
const DNSMASQ_LEASE_PATH: &str = "/tmp/tunshare-dnsmasq.leases";

/// DHCP server manager using dnsmasq.
pub struct DhcpServer {
    /// Whether the DHCP server is running.
    running: bool,
    /// The LAN interface to serve DHCP on.
    interface: String,
    /// The gateway IP (Mac mini's LAN IP).
    gateway_ip: Ipv4Addr,
    /// DNS servers to advertise to clients.
    dns_servers: Vec<String>,
}

impl DhcpServer {
    /// Create a new DHCP server instance.
    pub fn new(interface: &str, gateway_ip: Ipv4Addr, dns_servers: Vec<String>) -> Self {
        Self {
            running: false,
            interface: interface.to_string(),
            gateway_ip,
            dns_servers,
        }
    }

    /// Check if dnsmasq is installed and return its path.
    pub fn find_dnsmasq() -> Option<String> {
        // Check common Homebrew locations first (sudo might not have them in PATH)
        let common_paths = [
            "/opt/homebrew/sbin/dnsmasq",
            "/usr/local/sbin/dnsmasq",
            "/opt/homebrew/bin/dnsmasq",
            "/usr/local/bin/dnsmasq",
        ];

        for path in common_paths {
            if Path::new(path).exists() {
                return Some(path.to_string());
            }
        }

        // Fall back to which command
        SyncCommand::new("which")
            .arg("dnsmasq")
            .output()
            .ok()
            .filter(|o| o.status.success())
            .and_then(|o| String::from_utf8(o.stdout).ok())
            .map(|s| s.trim().to_string())
    }

    /// Check if dnsmasq is installed.
    pub fn is_dnsmasq_installed() -> bool {
        Self::find_dnsmasq().is_some()
    }

    /// Calculate DHCP range from gateway IP.
    /// Given gateway 192.168.2.1, returns ("192.168.2.100", "192.168.2.150").
    pub fn calculate_dhcp_range(gateway_ip: Ipv4Addr) -> (String, String) {
        let o = gateway_ip.octets();
        (
            format!("{}.{}.{}.100", o[0], o[1], o[2]),
            format!("{}.{}.{}.150", o[0], o[1], o[2]),
        )
    }

    /// Generate dnsmasq configuration.
    fn generate_config(&self) -> String {
        let (range_start, range_end) = Self::calculate_dhcp_range(self.gateway_ip);

        let dns_option = if self.dns_servers.is_empty() {
            // Use gateway as DNS if no VPN DNS available
            format!("dhcp-option=6,{}", self.gateway_ip)
        } else {
            format!("dhcp-option=6,{}", self.dns_servers.join(","))
        };

        format!(
            r#"# DHCP configuration - generated by tunshare
# Interface: {interface}
# Gateway: {gateway}

# Only listen on the specified interface
interface={interface}
bind-interfaces

# Don't use /etc/resolv.conf
no-resolv

# Don't provide DNS service (just DHCP)
port=0

# DHCP range and lease time
dhcp-range={range_start},{range_end},12h

# Gateway (option 3) - Mac mini's LAN IP
dhcp-option=3,{gateway}

# DNS servers (option 6)
{dns_option}

# Lease file
dhcp-leasefile={lease_file}

# PID file
pid-file={pid_file}

# Only DHCP, no DNS
dhcp-authoritative
"#,
            interface = self.interface,
            gateway = self.gateway_ip,
            range_start = range_start,
            range_end = range_end,
            dns_option = dns_option,
            lease_file = DNSMASQ_LEASE_PATH,
            pid_file = DNSMASQ_PID_PATH,
        )
    }

    /// Start the DHCP server.
    pub async fn start(&mut self) -> Result<()> {
        if self.running {
            return Ok(());
        }

        let dnsmasq_path = Self::find_dnsmasq().ok_or_else(|| TunshareError::CommandFailed {
            command: "dnsmasq".into(),
            message: "dnsmasq is not installed. Install with: brew install dnsmasq".into(),
        })?;

        // Stop any existing instance first
        Self::stop().await.ok();

        // Generate and write configuration
        let config = self.generate_config();
        fs::write(DNSMASQ_CONF_PATH, &config).map_err(TunshareError::Io)?;

        // Start dnsmasq (it will daemonize itself)
        let conf_arg = format!("--conf-file={}", DNSMASQ_CONF_PATH);
        let output = Command::new(&dnsmasq_path)
            .arg(&conf_arg)
            .output()
            .await
            .map_err(|e| TunshareError::CommandFailed {
                command: "dnsmasq".into(),
                message: e.to_string(),
            })?;

        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            return Err(TunshareError::CommandFailed {
                command: "dnsmasq".into(),
                message: format!("Failed to start DHCP server: {}", stderr),
            });
        }

        self.running = true;
        Ok(())
    }

    /// Stop any running DHCP server instance (async wrapper).
    /// Delegates to `stop_sync` via `spawn_blocking`.
    pub async fn stop() -> Result<()> {
        tokio::task::spawn_blocking(Self::stop_sync)
            .await
            .map_err(|e| TunshareError::CommandFailed {
                command: "dhcp stop (spawn_blocking)".into(),
                message: e.to_string(),
            })?;
        Ok(())
    }

    /// Synchronous stop. Single source of truth for DHCP cleanup.
    pub fn stop_sync() {
        // Try to read PID and kill the process
        if Path::new(DNSMASQ_PID_PATH).exists() {
            if let Ok(pid_str) = fs::read_to_string(DNSMASQ_PID_PATH) {
                if let Ok(pid) = pid_str.trim().parse::<i32>() {
                    let _ = SyncCommand::new("kill").arg(pid.to_string()).output();
                }
            }
        }

        // Also try pkill as a fallback
        let _ = SyncCommand::new("pkill")
            .args(["-f", &format!("dnsmasq.*{}", DNSMASQ_CONF_PATH)])
            .output();

        // Clean up files
        for path in [DNSMASQ_CONF_PATH, DNSMASQ_PID_PATH, DNSMASQ_LEASE_PATH] {
            if Path::new(path).exists() {
                let _ = fs::remove_file(path);
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_calculate_dhcp_range() {
        let range = DhcpServer::calculate_dhcp_range(Ipv4Addr::new(192, 168, 2, 1));
        assert_eq!(
            range,
            ("192.168.2.100".to_string(), "192.168.2.150".to_string())
        );

        let range = DhcpServer::calculate_dhcp_range(Ipv4Addr::new(10, 0, 0, 1));
        assert_eq!(range, ("10.0.0.100".to_string(), "10.0.0.150".to_string()));
    }

    #[test]
    fn test_generate_config() {
        let server = DhcpServer::new(
            "en0",
            Ipv4Addr::new(192, 168, 2, 1),
            vec!["10.8.0.1".to_string()],
        );
        let config = server.generate_config();

        assert!(config.contains("interface=en0"));
        assert!(config.contains("dhcp-range=192.168.2.100,192.168.2.150"));
        assert!(config.contains("dhcp-option=3,192.168.2.1"));
        assert!(config.contains("dhcp-option=6,10.8.0.1"));
    }
}
